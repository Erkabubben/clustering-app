using System;
using System.Text;
using System.Diagnostics;
using ClusteringAPI.Models;

namespace ClusteringAPI.Services
{
    public partial class ClusteringService
    {
        /// <summary>
        /// A Centroid used in K-Means Clustering.
        /// </summary>
        private class Centroid : IWordcountsList
        {
            private List<Blog> _blogAssignments;
            public List<Blog> BlogAssignments { get => _blogAssignments; set => _blogAssignments = value; }
            public List<double> Wordcounts { get => _wordcounts; set => _wordcounts = value; }
            public string PreviousAssignments { get => _previousAssignments; set => _previousAssignments = value; }
            public bool IsFinished { get => _isFinished; set => _isFinished = value; }

            private List<double> _wordcounts;
            private string _previousAssignments = "";
            private bool _isFinished = false;

            public Centroid()
            {
                _blogAssignments = new List<Blog>();
                _wordcounts = new List<double>();
            }

            public void Assign(Blog blog) => _blogAssignments.Add(blog);
            public void Assign(List<Blog> blogs, string blogName)
            {
                var blog = blogs.Find(b => b.Name == blogName);
                if (blog != null)
                    Assign(blog);
            }
        }

        /// <summary>
        /// Runs the ExecuteKMeansClustering() algorithm and returns the result as a KMeansClusteringResponse.
        /// </summary>
        /// <returns>KMeansClusteringResponse</returns>
        public KMeansClusteringResponse GetKMeansClusters()
        {
            var centroids = ExecuteKMeansClustering(5, 20);
            var responseData = new List<string[]>();
            foreach (var centroid in centroids)
            {
                var blogAssignments = new string[centroid.BlogAssignments.Count];
                for (int i = 0; i < centroid.BlogAssignments.Count; i++)
                {
                    Blog? blog = centroid.BlogAssignments[i];
                    blogAssignments[i] = blog.Name;
                }
                responseData.Add(blogAssignments);
            }
            return new KMeansClusteringResponse(responseData);
        }

        /// <summary>
        /// Returns an array of centroids generated by the K-Means Clustering algorithm.
        /// </summary>
        /// <param name="clustersAmount">The predetermined amount of clusters. </param>
        /// <param name="maxIterations">Max amount of iterations (loop will break early if no changes were made from last iteration).</param>
        /// <returns>Centroid[]</returns>
        private Centroid[] ExecuteKMeansClustering(int clustersAmount, int maxIterations)
        {
            // Number of words
            int n = _totalAmountOfWords;
            var centroids = new List<Centroid>();

            // Generate K random Centroids
            for (int i = 0; i < clustersAmount; i++)
            {
                var centroid = new Centroid();
                for (int j = 0; j < n; j++)
                    centroid.Wordcounts.Add(_random.Next(_minOccurences[i], _maxOccurences[i] + 1));
                centroids.Add(centroid);
            }

            // Iteration loop
            for (int i = 0; i < maxIterations; i++)
            {
                // Clear assignments for all centroids
                foreach (var centroid in centroids)
                    centroid.BlogAssignments = new List<Blog>();

                // Assign each blog to closest centroid
                foreach (var blog in _blogs)
                {
                    double distance = double.MaxValue;
                    Centroid? bestCentroid = null;
                    // Find closest centroid
                    foreach (Centroid centroid in centroids)
                    {
                        double centroidDistance = Pearson(centroid, blog);
                        if (centroidDistance < distance)
                        {
                            bestCentroid = centroid;
                            distance = centroidDistance;
                        }
                    }
                    if (bestCentroid != null)
                        bestCentroid.Assign(blog);
                }

                // Recalculate center for each centroid
                foreach (var centroid in centroids)
                {
                    // Find average count for each word
                    for (int j = 0; j < n; j++)
                    {
                        double avg = 0;
                        // Iterate over all blogs assigned to this centroid
                        foreach (var blog in centroid.BlogAssignments)
                            avg += blog.Wordcounts[j];

                        avg /= centroid.BlogAssignments.Count;

                        // Update word count for the centroid
                        centroid.Wordcounts[j] = avg;
                    }
                }
                // Check AssignmentsStrings against strings from previous iteration.
                foreach (var centroid in centroids)
                {
                    var assignmentsString = GetAssignmentsString(centroid);
                    if (centroid.PreviousAssignments == assignmentsString)
                        centroid.IsFinished = true;
                    else
                        centroid.PreviousAssignments = assignmentsString;
                }
                int amountOfFinishedCentroids = 0;
                // Break iteration loop if all centroids have finished.
                foreach (var centroid in centroids)
                    amountOfFinishedCentroids += centroid.IsFinished ? 1 : 0;
                if (amountOfFinishedCentroids == centroids.Count)
                    break;
                // End of iteration loop - all done.
            }
            return centroids.ToArray();
        }

        /// <summary>
        /// Gets an AssignmentString based on a cluster's blog assignments. Used to check
        /// if any changes were made since last iteration.
        /// </summary>
        /// <param name="centroid">The centroid to generate the string from.</param>
        /// <returns>string</returns>
        private string GetAssignmentsString(Centroid centroid)
        {
            string s = "";
            foreach (var blog in centroid.BlogAssignments)
                s += blog.Id;
            return s;
        }

        /// <summary>
        /// Prints an array of Centroids to the console.
        /// </summary>
        /// <param name="centroids">An array of centroids.</param>
        private void PrintCentroidClusters(Centroid[] centroids)
        {
            for (int i = 0; i < centroids.Length; i++)
            {
                Centroid? centroid = centroids[i];
                Console.WriteLine($"Cluster {i} ({centroid.BlogAssignments.Count}):");
                foreach (var blogAssignment in centroid.BlogAssignments)
                    Console.WriteLine('\t' + blogAssignment.Name);
            }
        }

    }
}
